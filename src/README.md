# Code Structure

**main.Main:**
The main program opens a simple terminal for interacting with the middleware to create and use views with the extended language. In this file, node and edge tables (and generally other map structures that are used to store the contents of views) are defined and populated.

**main.QueryParser:**
The parser for the tree generated by the grammar file [View.g4](./View.g4). The main functionality of the parser is to set up metadata and update the dependency table when parsing a query. This also utilizes [main.TableEntry](./main/TableEntry.java) and [main.EntryData](./main/EntryData.java), which constitute the dependency table.

**main.Neo4jGraphConnector:**
The interface for the connection between the application and the local Neo4j database. A config file is required to create the database. This class contains methods that return node and edge identifiers, which are subsequently stored in node/edge tables.

**jess:**
All methods or files that use or mention Jess were used when exploring discrimination networks (rule-based systems) to deal with materialized views, which offered incremental view updates. This also includes GraphEngine, NodeEnum, EdgeEnum, and any rule files in the /jess/ directory. However, the space complexity was too high, and we abandoned the idea.

**gen:**
This is the output destination for [View.g4](./View.g4). View.g4 is the language extension used for the project, and for the rest of the code to work, its output must be in gen. Note that if you change the language, you must recompile it, and as [QueryParser.java](./main/QueryParser.java) extends one of these classes (ViewBaseListener), you will need to update it accordingly. Please check ANTLR documentation on how to do this.

# How to Run the Middleware

1. First, ensure that you have populated the [config file](./config) with the correct paths to the database you want to use.
2. If you wish to use the same databases we used for generating the plots, run [load_data.py](./load_data.py) to download and load the databases. Then, update the [config file](./config) with the correct paths to these database instances.
3. Compile and run the terminal by executing the following commands (from the top directory):
    - `javac -sourcepath src -cp ".:./lib/*" src/main/Main.java`
    - `java -cp "lib/*:src/" main.Main`

## Prerequisites
Neo4j enterprise libraries should be located in /lib/. (The current code uses Neo4j version 5.3.0.) Additionally, you need the Jess library ([jess.jar](../lib/jess.jar) and [jsr94.jar](../lib/jsr94.jar)), along with the ANTLR jar files (currently using [antlr-4.8-complete](../lib/antlr4-4.8-1-complete.jar)).

# More Details on the Data Structures Used

- **nodeTable and edgeTable:** These data structures store, as the key, the view name used, along with the set of node or edge identifiers returned by the view. These tables form the core of the view materialization logic used in the middleware. They are instantiated and managed in [Main.java](./main/Main.java). Additionally, there are additional tables and data structures used for handling path views, but they are not fully integrated in this version of the project.

- **QueryParser:** [QueryParser](./main/QueryParser.java) traverses the tree and executes enter/exit on each component it encounters. Metadata is set up during these enter/exit methods, and the dependency table is kept updated when processing a view creation query. During processing of a view usage query, relevant variables are set up so that [Main.java](./main/Main.java) can determine which set of identifiers it should pull from the node or edge tables. For view updates, the dependency table is referenced, and a set of outdated views is returned to [Main.java](./main/Main.java).

- **DependencyTable:** [DependencyTable.java](./main/DependencyTable.java) is a hashtable with a graph component label as the key (Person, PARENT_OF, Post, etc.), and a [TableEntry](./main/TableEntry.java) object as the value.
    - **TableEntry:** [TableEntry.java](./main/TableEntry.java) contains a list of [EntryData](./main/EntryData.java), each associated with itself. For instance, a TableEntry :Post may have several EntryData, which differ due to the set of conditions.
    - **EntryData:** [EntryData.java](./main/EntryData.java) contains a condition list (which uniquely identifies it) and a list of views that depend on it. More information on these structures can be found in their respective Java files, mainly in TableEntry.
