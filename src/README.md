# Code Structure

main.Main:
The main program, which opens a simple terminal for interacting with the middleware to create/use views with the extended language. In this file, node and edge tables (and generally other map structures that aer used to store the contents of views) are defined and populated. 

main.QueryParser: 
The parser for the tree generated by the grammar file [View.g4](./View.g4). The main functionailiy of the parser is to set up meta-data and update the dependency table when parsing a query. This also uses [main.TableEntry](./main/TableEntry.java) and [main.EntryData](./main/EntryData.java) which make up the dependency table.

main.Neo4jGraphConnector:
The interface for the connection between the application and the local Neo4j database. A config file is required to create the database. This class contains methods which return node and edge identifiers that are subsequently stored in node/edge tables.

jess:
All methods or files that use or mention Jess were used when exploring discrimination networks (rule-based systems) to deal with materialized views, which offered an incremental view update. This also includes GraphEngine, NodeEnum, EdgeEnum, and any rule files in the /jess/ directory. However, the space complexity was too high and we abandoned the idea. 

gen:
This is the output destination for [View.g4](./View.g4). View.g4 is the language extension used for the project and for the rest of the code to work; its output must be in gen. Note that if you change the language you must recompile it, and as [QueryParser.java](./main/QueryParser.java) extends one of these classes (ViewBaseListener) you will need to update it accordingly. Please check ANTLR ddocumentation ocs on how to do this.

# How to run the middleware?
[TODO: here should be completed by me]

## Pre-reqs 
Neo4j enterprise libraries should be in /lib/. (The current code uses Neo4j version 5.3.0.) You also need the jess library ([jess.jar](../lib/jess.jar) and [jsr94.jar](../lib/jsr94.jar)) along with the antlr jar files (currently using [antlr-4.8-complete](../lib/antlr4-4.8-1-complete.jar)).

# More details on the data structures used

- nodeTable and edgeTable data structures store as the key the view name that is used, along with the set of node or edge identifiers returned by the view. These tabels are the core to the view materiliaztion logic used in the middleware. They are instanciated and managed in [Main.java](./main/Main.java). They are also additional tabels and data structures used for handling path views but they are not fully integrated in this version of the project.

- [QueryParser](./main/QueryParser.java) walks down the tree and executes enter/exit on each component it enters or exists. (For more details on the mechanism read ANTLR documentation). Meta-data are set-up during these enter/exit methods and the dependencyTable is kept updated upon processing a view creation query. 

    During processing a view usage query, relevant variables are set up so that the [Main.java](./main/Main.java) can know which set of identifiers it should pull from the node or edge tables. 

    For view updates, the dependency table is referenced and a set of outdated views is returned to [Main.java](./main/Main.java).

- [DependencyTable.java](./main/DependencyTable.java) is a hashtable with a graph component label as the key (Person, PARENT_OF, Post, etc) and a [TableEntry](./main/TableEntry.java) object as the value.
  
    - [TableEntry](./main/TableEntry.java) contains a list of [EntryData](./main/EntryData.java) which are associated with itself. For instance, a TableEntry :Post may have several EntryData, which differ due to the set of conditions.

    - [EntryData](./main/EntryData.java) contains a condition list (which uniquely identifies it) and a list of views which depend on it. More info on these structures are in their java files, mainly in TableEntry.